# Архитектура компьютера - Лаб 3

## Автор

> Калинин Даниил Дмитриевич, P33141

## Вариант (с упрощением)

> Исходный вариант: alg | risc | neum | hw | instr | binary | stream | mem | cstr | prob2 | pipeline\
> **Вариант после упрощения**:  asm | risc | neum | hw | instr | struct | stream | mem | cstr | prob2

### Описание варианта

- **asm** - язык программирования синтаксис ассемблера. Необходима поддержка label-ов.
- **risc** - система команд должна быть упрощенной, в духе RISC архитектур:
    - стандартизированная длина команд;
    - операции над данными осуществляются только в рамках регистров;
    - доступ к памяти и ввод-вывод -- отдельные операции (с учётом специфики вашего варианта mem/port);
- **neum** - фон Неймановская архитектура организация памяти
- **hw** - hardwired. Control unit реализуется как часть модели.
- **instr** - процессор необходимо моделировать с точностью до каждой инструкции (наблюдается состояние после каждой инструкции).
- **struct** - машинный код в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово.
- **stream** - ввод-вывод осуществляется как поток токенов. Есть в примере. Логика работы:
    - при старте модели у вас есть буфер, в котором представлены все данные ввода (['h', 'e', 'l', 'l', 'o']);
    - при обращении к вводу (выполнение инструкции) модель процессора получает "токен" (символ) информации;
    - если данные в буфере кончились -- останавливайте моделирование;
    - вывод данных реализуется аналогично, по выполнении команд в буфер вывода добавляется ещё один символ;
    - по окончании моделирования показать все выведенные данные;
    - логика работы с буфером реализуется в рамках модели на Python.
- **mem** - memory-mapped (порты ввода-вывода отображаются в память и доступ к ним осуществляется штатными командами),
    - отображение портов ввода-вывода в память должно конфигурироваться (можно hardcode-ом).
- **cstr** - Null-terminated (C string)
- **prob2** - Even Fibonacci numbers (сумма четных чисел Фибонначи, не превышающих 4 млн).

## Язык программирования

Язык программирования должен поддерживать:

- ветвления
- циклы
- математику
- строки (Null-terminated (C string))
- ввод/вывод
- label-ы

### Форма Бэкуса — Наура

```ebnf
// Команды и прочие элементы языка программирования

<program> ::= <program_line> | <program_line> "\n" <program>

<program_line> ::= <code_line> | <comment> | <code_line> <comment>

<code_line> ::=  <data_definition> | <label_definition> | <command>

<data_definition> ::= <label_definition> "\n" <data>

<data> ::= ".word" <number> | ".word" <string> | ".word" <label_name>

<command> ::= <zero_parameters_instruction> | <one_parameter_instruction> <address> | <two_parameter_instruction> <address> "," <address> | <branch_instruction> <address>

<address> = <label_name> | "(" <label_name> ")"

<label_definition> ::= <label_name> ":"

<label_name> ::= <word> 

<branch_instruction> ::= "jg" | "jz" | "jnz" | "jmp"

<two_parameter_instruction> ::= "add" | "sub" | "mov"

<one_parameter_instruction> ::= "inc" | "dec"

<zero_parameters_instruction> ::= "nop" | "hlt" 

<comment> ::= ";" <text>

// Строки

<string> ::= '"' <text> '"'

<text> ::= <word> | <word> <word>

<word> ::= <character> | <character> <word>

<character> ::= <symbol> | <letter> | <digit>

// Числа

<number> ::= [-] <non-negative number>

<non-negative number> ::= <digit> | <digit> <non-negative number>

// Основные термы

<symbol> ::=  "|" | " " | "-" | "!" | ...

<letter> ::= "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z"

<digit> ::= "0" | "1" | "2" |  ... | "9"
```

Строке программы может соответствовать:

- Пустая строка
- Комментарий `<comment>`
- Определение метки `<label_definition>`
- Определение данных `<data_definition> = <label_definition> + .word + Данные (число или строка)`
    - Здесь, конечно, 2 строки, но определение данных без обозначения метки не имеет смысла
- Команда `<command> = Инструкция + Адрес1 (если его наличие предусматривает инструкция) + , + Адрес2 (если его наличие предусматривает инструкция)`

### Семантика

- Глобальная видимость данных
- Поддерживаются целочисленные литералы (без ограничений на размер)
- Поддерживаются строковые литералы (Храняться в виде C-string)
    - Пример объявления строковых данных: .word 'Hello'
- Код выполняется последовательно
- Точка входа в программу -- метка _start (метка не может повторяться или отсутствовать)
- Название метки не должно:
    - совпадать с названием команды
    - начинаться с цифры
    - совпадать с ключевым словом .word
- Метки располагаются на строке, предшествующей строке с командой, операнды находятся на одной строке с командами
- Пробельные символы в конце и в начале строки игнорируются
- Любой текст, расположенный в конце строки после символа ; трактуется как комментарий
- Память выделяется статически, при запуске модели.

## Организация памяти

```text
Registers
+------------------------------------+
| R0 - регистр общего назначения     |
+------------------------------------+
| R1 - регистр общего назначения     |
+------------------------------------+
| R2 - регистр общего назначения     |
+------------------------------------+
| R3 - регистр общего назначения     |
+------------------------------------+
| IP - счетчик команд                |
+------------------------------------+
| SP - указатель стека (стек)        |
+------------------------------------+
| PS - регистр статуса               |
+------------------------------------+

Instruction & Data memory
+-----------------------------------------------+
|    0    :  jmp _start                         |
|    1    :  input_buffer                       |
|    2    :  ouput_str_buffer                   |
|    3    :  ouput_int_buffer                   |
|        ...                                    |
| _start  :  program start                      |
|        ...                                    |
|        ...                                    |
+-----------------------------------------------+
```

- Память данных и команд общая (фон Нейман)
- Слова знаковые
- Виды адресации:
    - абсолютная
    - косвенная
- Размер машинного слова равна **48 бит**:
    - Код команды (0-7) = **8 бит**
    - Бит косвенной адресации (8) = **1 бит** (0 - прямая адресация, 1 - косвенная адресация)
    - Зарезервировано (9-15) = **7 бит**
    - Адрес_1 (16-31) = **16 бит**, следовательно, в памяти **65536 ячеек**
    - Адрес_2 (32-47) = **16 бит**
    - (На практике кодирование команд реализовано через json)
- Стек реализован всего одним регистром SP, так как в рамках лабораторной необходимо хранить только адрес возврата при прерывании
- Структура PS (регистра состояния):
    - Флаг знака N (0) = **1 бит**
    - Флаг нуля Z (1) = **1 бит**
    - Зарезервировано (3-47) = **45 бит**
    - (На практике представлен словарем ключ-значение с ключами: "N", "Z")
- Адрес **0** зарезервирован для перехода к началу программы

## Система команд

### Безадресные команды

|Код|Команда|N|Z|Описание|Семантика|
|-|-|-|-|-|-|
|0| nop |-|-| Нет операции  | |
|1| hlt |-|-| Останов | |

### Адресные команды

| Код | Команда | N | Z | Адрес 1 | Адрес 2 | Описание | Семантика |
|-|-|-|-|-|-|-|-|
|4| inc |*|*|+| | Инкремент | addr1 + 1 -> addr1 |
|5| dec |*|*|+| | Декримент | addr1 - 1 -> addr1 |
|6| add |*|*|+|+| Сумма addr1 и addr2 | addr1 + addr2 -> addr1 |
|7| sub |*|*|+|+| Разница addr1 и addr2 | addr1 - addr2 -> addr1 |
|8| mov |*|*|+|+| Загрузить в addr1 значение по addr2 | addr2 -> addr1 |
|9| test |*|*|+|+| Логическое И addr1 и addr2 | addr1 & addr2 -> addr1 |

### Команды ветвления

| Код | Команда | N | Z | Адрес 1 | Адрес 2 | Описание | Семантика |
|-|-|-|-|-|-|-|-|
|9| jg |-|-|+| | Перейти по адресу, если флаг N == 0 | |
|10| jz |-|-|+| | Перейти по адресу, если флаг Z == 0 | |
|11| jnz |-|-|+| | Перейти по адресу, если флаг Z != 0 | |
|12| jmp |-|-|+| | Перейти к адресу | addr1 -> IP |

### Кодирование инструкций

- Машинный код сереализуется в список JSON
- Один элемент списка -- одна инструкция

Пример:

```json
[
    {
        "index": 0,
        "opcode": "mov",
        "addr_1": "r1",
        "is_indirect_1": false,
        "addr_2": "r2",
        "is_indirect_2": false
    }
]
```

где:

- `index` - адрес в памяти
- `opcode` - код операции
- `addr_1` - адресс_1
- `is_indirect_1` - косвенная ли адресация для addr_1
- `addr_2` - адресс_2
- `is_indirect_2` - косвенная ли адресация для addr_2

Типы данных в модуле [isa](./isa.py), где:

- `Opcode` - перечисление кодов операций
